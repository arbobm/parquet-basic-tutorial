---
title: "Parquet Basics"
subtitle: ''
date: "03 June 2025"
date-format: DD-MM-YYYY
date-modified: "`r Sys.Date()`"
published-title: Created
format:
  html:
    embed-resources: true
    code-fold: true
    code-overflow: wrap
    theme: cosmo
    toc: true
    toc-expand: 3
    canonical-url: true
    code-copy: true
  pdf: default
execute: 
  warning: false
  error: false
  message: false
  echo: false
# bibliography: references.bib
lightbox: # https://quarto.org/docs/output-formats/html-lightbox-figures.html
  match: auto
  effect: fade
  desc-position: right
dpi: 500
---

# Welcome to the fantastic world of Parquet

## What is it?

Apache Parquet is an open source, column-oriented data file format designed for efficient data storage and retrieval. It provides high performance compression and encoding schemes to handle complex data in bulk and is supported in many programming language and analytics tools^[https://parquet.apache.org/docs/overview/].

> The open-source project to build Apache Parquet began as a joint effort between Twitter[3] and Cloudera.[4] Parquet was designed as an improvement on the Trevni columnar storage format created by Doug Cutting, the creator of Hadoop. The first version, Apache Parquet 1.0, was released in July 2013. Since April 27, 2015, Apache Parquet has been a top-level Apache Software Foundation (ASF)-sponsored project.

## Why should we care?

Apache Parquet is a file format designed to support fast data processing for complex data, with several notable characteristics:

1. **Columnar:** Unlike row-based formats such as CSV, Apache Parquet is column-oriented – meaning the values of each table column are stored next to each other, rather than those of each record:

![](https://www.upsolver.com/wp-content/uploads/2020/05/Screen-Shot-2020-05-26-at-17.52.58.png)

The key difference between a CSV and Parquet file format is how each one is organized. A Parquet file format is structured by row, with every separate column independently accessible from the rest. Since the data in each column is expected to be of the same type, the parquet file format makes encoding, compressing and optimizing data storage possible.

2. **Open-source:** Parquet is free to use and open source under the Apache Hadoop license. 

> Apache Parquet is a columnar storage format available to any project […], regardless of the choice of data processing framework, data model or programming language^[https://parquet.apache.org/].

3. **Self-describing:** In addition to data, a Parquet file contains metadata including schema and structure. Each file stores both the data and the standards used for accessing each record – making it easier to decouple services that write, store, and read Parquet files.
4. **Binary format:** Parquet file formats store data in binary format, which reduces the overhead of textual representation. It's important to note that Parquet files are not stored in plain text, thus cannot be opened in a text editor.

## Advantages of Parquet Columnar Storage – Why Should You Use It?

The above characteristics of the Apache Parquet file format create several distinct benefits when it comes to storing and analysing large volumes of data. 

::: {.panel-tabset}

### Compression

File compression is the act of taking a file and making it smaller. In Parquet, compression is performed column by column and it is built to support flexible compression options and extendable encoding schemas per data type – e.g., different encoding can be used for compressing integer and string data.

Parquet data can be compressed using these encoding methods:

* **Dictionary encoding:** this is enabled automatically and dynamically for data with a small number of unique values.
* **Bit packing:** Storage of integers is usually done with dedicated 32 or 64 bits per integer. This allows more efficient storage of small integers.
* **Run length encoding (RLE):** when the same value occurs multiple times, a single value is stored once along with the number of occurrences. Parquet implements a combined version of bit packing and RLE, in which the encoding switches based on which produces the best compression results.

<!--     Data compression -->

<!-- Parquet file formats support various compression algorithms, such as Snappy, Gzip, and LZ4, resulting in smaller file sizes, compared to uncompressed formats like CSV. You can expect a size reduction of nearly 75% for your data in Parquet files from other formats. -->

<!--     Embedded metadata -->

<!-- Parquet file formats include metadata that provide information about the schema, compression settings, number of values, location of columns, minimum value, maximum value, number of row groups and type of encoding.  -->

<!-- Embedded metadata helps in efficiently reading and processing the data. Any program that's used to read the data can also access the metadata to determine what type of data is expected to be found in a given column. -->

### Performance

As opposed to row-based file formats like CSV, Parquet is optimized for performance. When running queries on your Parquet-based file-system, you can focus only on the relevant data very quickly. Moreover, the amount of data scanned will be way smaller and will result in less I/O usage. To understand this, let's look a bit deeper into how Parquet files are structured.

As we mentioned above, Parquet is a self-described format, so each file contains both data and metadata. Parquet files are composed of row groups, header and footer. Each row group contains data from the same columns. The same columns are stored together in each row group:

![](https://www.upsolver.com/wp-content/uploads/2020/05/Screen-Shot-2020-05-26-at-17.53.13.png)
This structure is well-optimized both for fast query performance, as well as low I/O (minimizing the amount of data scanned). For example, if you have a table with 1000 columns, which you will usually only query using a small subset of columns. Using Parquet files will enable you to fetch only the required columns and their values, load those in memory and answer the query. If a row-based file format like CSV was used, the entire table would have to have been loaded in memory, resulting in increased I/O and worse performance.

<!--     Splittable and parallel processing -->

<!-- Parquet file formats are designed to be splittable, meaning they can be divided into smaller chunks for parallel processing in distributed computing frameworks like Apache Hadoop and Apache Spark. -->
<!-- Parquet file format vs CSV -->

<!-- While CSV is widely used in major organizations, CSV and Parquet file formats are suitable for different use cases. Let's look at the differences between these two specific formats in order to help you choose a data storage format. -->

<!--     Storage efficiency -->

<!-- Parquet file format is a columnar storage format, which means that data for each column is stored together. The storage mechanism enables better compression and typically results in smaller file sizes compared to row-based formats. -->

<!-- CSV is a row-based format, where each row is represented as a separate line in the file. The format does not offer compression, often resulting in larger file sizes. -->

<!--     Query performance -->

<!-- CSVs need you to read the entire file to query just one column, which is highly inefficient. -->

<!-- On the other hand, Parquet's columnar storage and efficient compression makes it well-suited for analytical queries that only need to access specific columns. This compression leads to faster query performance when dealing with large datasets. A  recent [survey by Green Shield Canada](https://posit.co/blog/speed-up-data-analytics-with-parquet-files/){target="_blank"} found that with the parquet file format, they were able to process and query data 1,500 times faster than with CSVs.  -->

### Schema evolution

When using columnar file formats like Parquet, users can start with a simple schema, and gradually add more columns to the schema as needed. In this way, users may end up with multiple Parquet files with different but mutually compatible schemas. In these cases, Parquet supports automatic schema merging among these files.

<!--     Schema evolution -->

<!-- Parquet file format supports schema evolution by default, since it's designed with the dynamic nature of computer systems in mind. The format allows you to add new columns of data without having to worry about your existing dataset.  -->

<!-- CSV files on the other hand, do not inherently support schema evolution, which can be a limitation if your data schema changes frequently. -->

:::

## Column-Oriented vs Row-Based Storage for Analytic Querying

Data is often generated and more easily conceptualized in rows. We are used to thinking in terms of Excel spreadsheets, where we can see all the data relevant to a specific record in one neat and organized row. However, for large-scale analytical querying, columnar storage comes with significant advantages with regards to cost and performance.

Complex data such as logs and event streams would need to be represented as a table with hundreds or thousands of columns, and many millions of rows. Storing this table in a row based format such as CSV would mean:

* Queries will take longer to run since more data needs to be scanned, rather than only querying the subset of columns we need to answer a query (which typically requires aggregating based on dimension or category)
* Storage will be more costly since CSVs are not compressed as efficiently as Parquet

Columnar formats provide better compression and improved performance out-of-the-box, and enable you to query data vertically – column by column. <!-- https://www.upsolver.com/blog/apache-parquet-why-use -->

images columns row^[https://data-mozart.com/parquet-file-format-everything-you-need-to-know/]
![](https://data-mozart.com/wp-content/uploads/2023/04/Row-store.png)
![](https://data-mozart.com/wp-content/uploads/2023/04/Row-based-scan.png)
![](https://data-mozart.com/wp-content/uploads/2023/04/Column-store.png)

![](https://data-mozart.com/wp-content/uploads/2023/04/Row-groups.png)

![](https://data-mozart.com/wp-content/uploads/2023/04/Scan-eliminate.png)
Let’s quickly stop here, as I want you to realize the difference between various types of storage in terms of the work that needs to be performed by the engine:

    Row store – the engine needs to scan all 5 columns and all 6 rows
    Column store – the engine needs to scan 2 columns and all 6 rows
    Column store with row groups – the engine needs to scan 2 columns and 4 rows
    
# I'm tired of reading non-sense

Ok, then let me introduce you to the R packages I've been exploring and how they made my life easier.

## arrow

The R arrow package provides access to many of the features of the Apache Arrow C++ library for R users. The goal of arrow is to provide an Arrow C++ backend to dplyr, and access to the Arrow C++ library through familiar base R and tidyverse functions, or R6 classes. The dedicated R package website is located [here](https://arrow.apache.org/docs/r/index.html).


What can the arrow package do?

The arrow package provides binding to the C++ functionality for a wide range of data analysis tasks.

* It allows users to read and write data in a variety formats:
  * Read and write Parquet files, an efficient and widely used columnar format
  * Read and write Arrow (formerly known as Feather) files, a format optimized for speed and interoperability
  * Read and write CSV files with excellent speed and efficiency
  * Read and write multi-file and larger-than-memory datasets
  * Read JSON files
* It provides access to remote file systems and servers:
  * Read and write files in Amazon S3 and Google Cloud Storage buckets
  * Connect to Arrow Flight servers to transport large datasets over networks
* Additional features include:
  * Manipulate and analyse Arrow data with dplyr verbs
  * Zero-copy data sharing between R and Python
  * Fine control over column types to work seamlessly with databases and data warehouses
  * Toolkit for building connectors to other applications and services that use Arrow

What is Apache Arrow?

Apache Arrow is a cross-language development platform for in-memory and larger-than-memory data. It specifies a standardized language-independent columnar memory format for flat and hierarchical data, organized for efficient analytic operations on modern hardware. It also provides computational libraries and zero-copy streaming, messaging, and interprocess communication.

### Arrow resources

There are a few additional resources that you may find useful for getting started with arrow:

* The official [Arrow R package documentation](https://arrow.apache.org/docs/r/){target="_blank"}
* [Arrow for R cheatsheet](https://github.com/apache/arrow/blob/-/r/cheatsheet/arrow-cheatsheet.pdf){target="_blank"}
* [Apache Arrow R Cookbook](https://arrow.apache.org/cookbook/r/index.html){target="_blank"}
* R for Data Science [Chapter on Arrow](https://r4ds.hadley.nz/arrow){target="_blank"}
* [Awesome Arrow R](https://github.com/thisisnic/awesome-arrow-r){target="_blank"}

### Installation

The latest release of arrow can be installed from CRAN. In most cases installing the latest release should work without requiring any additional system dependencies, especially if you are using Windows or macOS.

```{r}
install.packages("arrow")
```

If you are having trouble installing from CRAN, then we offer two alternative install options for grabbing the latest arrow release. First, R-universe provides pre-compiled binaries for the most commonly used operating systems.

```{r}
# install.packages("arrow", repos = c("https://apache.r-universe.dev", "https://cloud.r-project.org"))
```

### Get started with Arrow

```{r}
library(arrow, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)

starwars
write_parquet(starwars, 'starwars.parquet')

```

```{r}
sw_frame <- read_parquet('starwars.parquet')
sw_table <- read_parquet('starwars.parquet', as_data_frame = FALSE)
sw_table
```
#### Multi-file data sets

```{r}
set.seed(1234)
nrows <- 100000
random_data <- data.frame(
  x = rnorm(nrows),
  y = rnorm(nrows),
  subset = sample(10, nrows, replace = TRUE)
)
```

```{r}
dataset_path <- "random_data"
```

```{r}
random_data %>%
  group_by(subset) %>%
  write_dataset(dataset_path)
```

```{r}
list.files(dataset_path, recursive = TRUE)
```
Each of these Parquet files can be opened individually using `read_parquet()` but is often more convenient – especially for very large data sets – to scan the folder and “connect” to the data set without loading it into memory. We can do this using `open_dataset()`:

```{r}
dset <- open_dataset(dataset_path)
dset
```

#### Analising Arrow data with `dplyr`

```{r}
dset %>%
  group_by(subset) %>%
  summarize(mean_x = mean(x), min_y = min(y)) %>%
  filter(mean_x > 0) %>%
  arrange(subset) %>%
  collect()
```


<!-- check articles to show better how to use the filtering thing -->



### example from real life with ebird pts?

## geoparquet - sfarrow

### example from real life with rangemaps?

## tidyverse - parquet

https://www.tidyverse.org/blog/2025/01/nanoparquet-0-4-0/















